# 数据结构笔记

## 复习提纲



1、 顺序表插入、删除：算法2.7\2.8

```c
void insert(sequence_list *slt,datatype x,int position){
	int i;
	if (slt->size == MAXSIZE)
	{
		printf("\n顺序表是满的！无法插入！");
		exit(1);
	}
	if (position < 0 || position > slt->size)
	{
		printf("\n指定的插入位置不存在！");
		exit(1);
	}
	for (i = slt->size; i > position; i--)
	{
		slt->a[i] = slt->a[i-1];
	}
	slt->a[position] = x;
	slt->size++;
}

void dele(sequence_list *slt,datatype x,int position){
	int i;
	if (slt->size == MAXSIZE)
	{
		printf("\n顺序表是满的！无法插入！");
		exit(1);
	}
	if (position < 0 || position > slt->size)
	{
		printf("\n指定的插入位置不存在！");
		exit(1);
	}
	for (i = position; i < slt->size - 1; i++)
	{
		slt->a[i] = slt->a[i+1];
	}
	slt->size--;
}
```

2、 顺序栈的出入：算法2.12\2.13

```c
void push(sequence_stack *st,datatype x){
    if (st->top == MAXSIZE)
    {
        printf("\n is Full");
        exit(1);
    }
    st->a[st->top] = x;
    st->top++;
    
}

void pop(sequence_stack *st){
    if (st->top == 0)
    {
        printf("\nThe sequence stack is empty !");
        exit(1);
    }
    st->top--;
}
```



3、 顺序队列的出入：算法2.24\2.25

```c
void insert(sequece_queue *sq,datatype x){
	int i;
	if (sq->rear == MAXSIZE)
	{
		printf("\n顺序队列是满的！");
		exit(1);
	}
	sq->a[sq->rear] = x;
	sq->rear = sq->rear + 1;
}

void dele(sequece_queue *sq){
	if (sq->front == sq->rear)
	{
		printf("\n顺序队列是空的！");
		exit(1);
	}
	sq->font++;
}
```



4、 顺序循环队列的出入：算法2.26\2.27

```c
void insert_sequence_cqueue(sequence_queue *sq;datatype x){
    if ((sq->rear + 1) % MAXSIZE == sq->front)
    {
        printf("full");
        exit(1);
    }
    sq->a[sq-rear] = x;
    sq->rear = (sq->rear + 1) % MAXSIZE;

//rear+1如果是满的就是和front在同一个位置了，比maxsize要大，所以取余就是front的位置
    
}

void dele_sequence_cqueue(sequence_queue *sq){
    if (sq->front == sq->rear)
    {
        printf("empty");
        exit(1);
    }
    sq->front = (sq->front + 1) % MAXSIZE;
}
```



5、 单链表的插入、删除、输出：算法3.7\3.9\3.10

```c
void display(node *head){
	node *p;
	p = head->next;
	if (!p)
	{
		printf("\nempty!");
	}
	else
	{
		while(p){
			printf("%5d\n",p->info);
			p = p->next;
		}
	}
}


node *insert(node *head,datatype x,int i){
	node *p,*q;
	q = find(head,i);
	if (!q)
	{
		printf("\nno this node");
		return head;
	}
	p = (node*)malloc(sizeof(node));
	p->info = x;
	p->next = q->next;
	q->next = p;
	return head;
}

node *dele(node *head,datatype x){
	node *pre = head;
	node *q;
	q = head->next;
	while(q && q->info != x){
		pre = q;  
		q = q->next;
	}
	if (q)
	{
		pre->next = q->next;  //pre指向q的前驱 
		free(q);
	}
}
```



6、 二叉树的前中后三种递归遍历：算法7.1\7.2\7.3

P132

7、 概念：数据结构相关内容、顺序表、单链表、栈、队列及其两种存储方式

梳理：数据结构包含哪三个方面、每个方面又是什么含义P2-5

​	顺序表 概念P11，特点

单链表：链式存储——内存不一定连续。带头结点或不带头结点  这两种的本质区别 P35 图3.3对比图3.6  P40

栈的概念P16  两种存储方式 ，重点是顺序存储—— top的值 代表空或满

队列的概念P26  两种存储方式 ，重点是顺序存储——（循环与不循环之分）front和rear  什么状态代表是空的，什么状态代表满的。

 

8、 算法和程序的特征、时间复杂度和空间复杂度的概念

P8倒数第二段，P9第一段和倒数第二段

 

9、 出栈序列的推理  后进先出

进栈顺序为A、B、C、D，在进栈过程中可以出栈，请找出哪一个不可能d

a、CDBA    sssxsxxx

b、ABCD

c、ACDB

d、ADBC

 

10、 顺序循环队列中元素个数的计算、满的条件、空的条件

（rear-front+ MAXSIZE）% MAXSIZE——  个数

满——算法2.26里的if条件    (rear+1)%MAXSIZE == front

空——算法2.27里的if条件    rear == front

11、 顺序循环队列中元素个数的计算、满的条件、空的条件

???  ——  个数

满——算法2.24里的if条件    ?

空——算法2.25里的if条件    ?

 

12、 二维数组存储地址的计算——基地址+前有多少个*单位字节

P93   4.2  对称需要压缩存储  计算a65地址  （前有i行等腰直角三角形，左有j个）

​    变形：对称不压缩存储  计算a65的地址  （前有i行矩形，左有j个）

13、 稀疏矩阵压缩的概念、存储方式

概念P87  第一段

存储方式两种：顺序存储：三元组顺序表

​			       链式存储：十字链表

​		

14、 树的基本概念、树的遍历方法

概念P110-111

存储：双亲表示法、孩子表示法（数组）、孩子链表表示法、孩子兄弟表示法P112-116

遍历：前序、后序、层次三种

 

15、 二叉树的性质

P126  

满二叉树、完全二叉树的概念

二叉树的存储：一般二叉树的顺序存储、完全二叉树的顺序存储、二叉链表

二叉树的遍历：前序、中序、后序    两种：由树得序列、由序列得树

 

16、 图的基本概念、图的存储、图的两种遍历方法、图最小生成树的概念

概念P146-148

存储：邻接矩阵（有向无向、带权或不带权）P184  图8.36~8.37，图8.39-图8.40

​    P 151 图 8.9  不带权  图8.20 带权（***\*统一按教材，主对角线为0\****）

   邻接表（有向无向、带权或不带权）P184 图8.38  P154图8.11

遍历：DFS、BFS

最小生成树的概念：  肯定是带权、连通    包含的顶点数与边的数量的关系

最小生成树的算法：（1）普里姆（prim）P164 图8.21（虚线存在问题）

![img](file:////tmp/wps-adian/ksohtml/wps2L8OrD.png) 

（d）图用刀一切，切到两条最小权值的边均为6，选取任意一条即可。

最小生成树的算法：（2）克鲁斯卡尔（kruskal）P166 图8.23

 

17、 顺序检索成功与不成功时比较次数、ASL

静态检索——线性表的检索

（1） 顺序检索：算法P187，   P188 （9-2）成功时的ASL，(9-3)不成功时的比较次数

（2） 二分检索：算法P190-191，   P191，（9-6）ASL

（3） 分块检索：算法P192，   P193 （9-7）需要修改、（9-8）

动态检索——9.3节9.4节 （未讲）

18、 二分检索时查找某关键字时所需的比较次数的计算 P230第一个选择题  B

以key = 45举例，  后两个关键字请自行推理

（1） L = 0，H = 8à M = (0+8)/2 = 4  data[M]>key，所以45在左半区 à H=M-1=3

（2） L= 0，H=3 àM = (0+3)/2 = 1  data[M]<key  所以45在右半区  àL = M+1 = 2

（3） L = 2，H = 3àM =(2+3)/2 = 2  data[M] <key 所以45在右半区  àL = M+1 =3

（4） L = 3, H = 3 àM =    =3   data[3] == key  找到了

结论：比较了几次  4次  

 

 

***\*综合应用：\****

1、 树：存储结构P112-116、树与二叉树相互转换P143 图7.9~7.11

2、二叉树：由2种遍历序列反推树，并得到第三种遍历序列  P145  7.7  7.10

3、赫夫曼树及编码 ：P231  9.10  8 改成7  要求画 左大右小的Huffman树，得到每个字符的Huffman编码 左1右0。

4、图的存储两种及最小生成树的两种生成算法